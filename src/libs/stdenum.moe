def enum = enumeration;
def export(n)(x) = 
	exports[n] = x
	x

-- function takeWhile: Wraps an enumerable object, emits terms until it satisifies the condition
-- takeWhile: (Enumerable(T), T -> Boolean) -> Enumerable(T)
def export("takeWhile") Enumerable takeWhile(I, condition):
	for(var *a in I)
		if(not condition.apply null, a)
			return undefined;
		() <- a

-- function select: Wraps an enumerable object, only emits terms satisifying the condition
-- select: (Enumerable(T), T -> Boolean) -> Enumerable(T)
def export("select") Enumerable select(I, condition):
	for(var *a in I)
		if(condition.apply null, a)
			() <- a

-- function table: Creates lists using list comprehension monad.
-- table: MonadicPrimitive(* -> T) -> [T]
def export("table") table(G) =
	var ans = []
	def fReturn(x) = case(x)
		when(undefined) pass
		otherwise       ans.push x
	def fYield(x) = x
	def fBind(list, callback) =	rangeFor list, callback
	def schemata = [yield: fYield, return: fReturn, bind: fBind]

	(G.build schemata).apply(this, arguments)()

	ans