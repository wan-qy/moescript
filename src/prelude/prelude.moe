// Moe Standard Prelude
// Copyright(c) 2012 Belleve Invis

def derive = exports.derive
def Object = exports.Object
def object = exports.object
def global_ = exports.global_
def Array = exports.Array

def MONAD_SCHEMATA_M = moert.runtime.MONAD_SCHEMATA_M
def OWNS = moert.runtime.OWNS
def YIELDVALUE = moert.runtime.YIELDVALUE
def RETURNVALUE = moert.runtime.RETURNVALUE

def export(n)(x) = (exports[n] = x)



// Util functions

def export('its') its(prop)(o) = o[prop]
def export('returns') returns(x)() = x
def export('itself') itself(x) = x
def export('composite') composite(f, g)() = f (do g)
def export('doon') doon(o, f) = f.call o
def export('tee') tee(o, f) =
	f.call o, o
	o

def export('list') list = object =>
	def @car(a) = a[0]
	def @cdr(a) = a.slice 1
	def @initial(a) = a.slice 0, (-1)
	def @last(a) = a[a.length - 1]
	def cat(a, b) = a.concat b
	def @flat(a) = a.reduce cat, []
	def @fill(range, x) = table { i <- range; x }
	def @tolist(range) = table { x <- range; x }

def isBack(f) = [be: f]
def export('empty') isBack empty(x) = (not x) or (x.length === 0)

// Enumeration functions

-- Enumeration monad schemata
def ENUM_SCHEMATA = object MONAD_SCHEMATA_M, :>
	def @return(v)        = new RETURNVALUE v
	def @bind(g, restart) = new YIELDVALUE g, restart

-- Emitter generator
def generateEmitter(g) = 
	var emitRestart = g
	return =>
		def v = do emitRestart
		if(v.restart and v.values)
			emitRestart = v.restart
			return v.values

-- function enumeration: Generates emitters, used for adding methods.
def export('enumeration') enumeration(G) = 
	def e = G.build ENUM_SCHEMATA
	return => 
		generateEmitter e.apply this, arguments

def enumeration.bypass  = ENUM_SCHEMATA.bind
def enumeration.yield() = new YIELDVALUE (list.initial arguments), (list.last arguments)

-- function Enumerable: creates objects containing "getEnumerator" method.
-- Enumerable: (MonadPrimitive(* -> [T])) -> Enumerable T
def export('Enumerable') Enumerable(G) = 
	def enumFunction = G.build ENUM_SCHEMATA
	return => 
		[getEnumerator: (=> generateEmitter enumFunction.apply t, a)]
		where t = this
		      a = arguments

-- function getEnumeratorOf: Returns an enumerator of an Enumerable object
-- Defined in moert
-- getEnumeratorOf: (Enumerable T) -> Enumerator T
def export('getEnumeratorOf') getEnumeratorOf = moert.runtime.GET_ENUM

-- function rangeForEach: A "sometimes-faster" way to run "for" on a function
-- Approximately for(var *a in range) f.apply null, a
-- rangeForEach: (Enumerable T, T -> *) -> *
def export('rangeForEach') rangeForEach(range, f) = 
	def e = getEnumeratorOf range
	if(e.each) e.each f
	else
		var t = null
		while((t = e())) f.apply null, t

-- function takeWhile: Wraps an enumerable object, emits terms until it satisifies the condition
-- takeWhile: (Enumerable T, T -> Boolean) -> Enumerable(T)
def export("takeWhile") Enumerable takeWhile(I, condition):
	for(var *a in I)
		if(not condition.apply null, a)
			return undefined;
		() <- a

-- function select: Wraps an enumerable object, only emits terms satisifying the condition
-- select: (Enumerable T, T -> Boolean) -> Enumerable(T)
def export("select") Enumerable select(I, condition):
	for(var *a in I)
		if(condition.apply null, a)
			() <- a

-- function table: Creates lists using list comprehension monad.
-- table: MonadicPrimitive(* -> T) -> [T]
def export("table") table(G) =
	var ans = []
	def schemata = object MONAD_SCHEMATA_M, =>
		def @return(x) = case(x)
			when(undefined) pass
			otherwise       ans.push x
		def @bind(list, callback) = rangeForEach list, callback

	(do G.build schemata)()

	ans



// Async functions

-- CPS schemata
def cpsSchemata = derive MONAD_SCHEMATA_M

-- function async: Creates async blocks
def export('async') async(M) = 
	if(M.build)
		(=> (do g)()) where g = M.build cpsSchemata
	else => do M

def export('join') join(o, callback) = 
	var nActivities = 0
	var nDone = 0
	var res = []  when(o is Array),
	          [:]

	def checkContinue(term)(val):
		res[term] = val
		nDone += 1
		if(nDone >= nActivities) callback res

	var keys = Object.keys o
	if(not keys.length) callback res
	nActivities = keys.length

	rangeForEach keys, (term) =>
		res[term] = undefined
		o[term].call null, checkContinue(term)

def export('sleep') sleep(dt, callback) = 
	global_.setTimeout(callback, dt)



// Pattern match functions
def matcher(G) = 
    var fMatcher = (x) => undefined;
    def schemata = object MONAD_SCHEMATA_M, =>
        def @bindYield(extractor, thisp, gotcha, mismatch):
            mismatch()
            fMatcher = extractor.formMatch.call thisp, gotcha, fMatcher
    	
    G.build(schemata)()()
    return fMatcher

def export('match') match(x, G) =
	if (not G) matcher(x)
	else       matcher(G) x

def export('extractor') extractor(formFunc) =
	def f = formFunc {true}, {false}
	f.formMatch = formFunc
	f.be = f
	f

def export('Both') Both() = 
	var extractors = arguments;
	return extractor function(got, miss) =
		extractors.reduceRight ((total, extractor) => extractor.formMatch total, miss), got

def export('Either') Either() = 
	var extractors = arguments;
	return extractor function(got, miss) =
		extractors.reduceRight ((total, extractor) => extractor.formMatch got, total), miss
